<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="前言其实讲服务端路由有点不合理，本质上来说应该是RPC远程过程调用。设计路由的本质是要解决业务模块化依赖问题，而这里所想要解决是微服务之间的服务调用问题。这里使用技术栈是(Spring+Netty+Protostuff+Eureka)。  Spring：主要使用依赖注入以及相关的注解 Netty：使用TCP进行服务间通信 Protostuff: 负责序列化和反序列化 eureka：服务注册及实例">
<meta property="og:type" content="article">
<meta property="og:title" content="服务端路由设计">
<meta property="og:url" content="http://yoursite.com/2018/03/30/RPC框架/index.html">
<meta property="og:site_name" content="Kevin">
<meta property="og:description" content="前言其实讲服务端路由有点不合理，本质上来说应该是RPC远程过程调用。设计路由的本质是要解决业务模块化依赖问题，而这里所想要解决是微服务之间的服务调用问题。这里使用技术栈是(Spring+Netty+Protostuff+Eureka)。  Spring：主要使用依赖注入以及相关的注解 Netty：使用TCP进行服务间通信 Protostuff: 负责序列化和反序列化 eureka：服务注册及实例">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/03/30/RPC框架/微服务.png">
<meta property="og:updated_time" content="2018-03-30T07:23:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="服务端路由设计">
<meta name="twitter:description" content="前言其实讲服务端路由有点不合理，本质上来说应该是RPC远程过程调用。设计路由的本质是要解决业务模块化依赖问题，而这里所想要解决是微服务之间的服务调用问题。这里使用技术栈是(Spring+Netty+Protostuff+Eureka)。  Spring：主要使用依赖注入以及相关的注解 Netty：使用TCP进行服务间通信 Protostuff: 负责序列化和反序列化 eureka：服务注册及实例">
<meta name="twitter:image" content="http://yoursite.com/2018/03/30/RPC框架/微服务.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/30/RPC框架/"/>





  <title>服务端路由设计 | Kevin</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">This is subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/30/RPC框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Hao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/13860006?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">服务端路由设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-30T10:28:42+08:00">
                2018-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/路由/" itemprop="url" rel="index">
                    <span itemprop="name">路由</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>其实讲服务端路由有点不合理，本质上来说应该是RPC远程过程调用。设计路由的本质是要解决业务模块化依赖问题，而这里所想要解决是微服务之间的服务调用问题。这里使用技术栈是(Spring+Netty+Protostuff+Eureka)。</p>
<ol>
<li>Spring：主要使用依赖注入以及相关的注解</li>
<li>Netty：使用TCP进行服务间通信</li>
<li>Protostuff: 负责序列化和反序列化</li>
<li>eureka：服务注册及实例维护</li>
</ol>
<p>一般来说一个微服务架构如下图所示，我们需要将服务部署在分布式环境下的不同节点上，通过服务注册的方式，让客户端来自动发现当前可用的服务，并调用这些服务。这需要一种服务注册表，让它来注册分布式环境下所有的服务地址（包括：主机名与端口号）。<br><img src="/2018/03/30/RPC框架/微服务.png" alt=""></p>
<h4 id="服务端注册"><a href="#服务端注册" class="headerlink" title="服务端注册"></a>服务端注册</h4><p>主要通过Spring扫描所以注解的Service，然后拿这些服务去注册中心注册去。<br><figure class="highlight plain"><figcaption><span>HippoService</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface HippoService &#123;</span><br><span class="line">  String serviceName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>AuthService</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@HippoService(serviceName = &quot;user&quot;)</span><br><span class="line">public interface AuthService &#123;</span><br><span class="line">    AuthResponse login(AuthRequest request);</span><br><span class="line">    boolean logout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@HippoServiceImpl</span><br><span class="line">public class AuthServiceImpl implements AuthService&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现细节如下，主要是利用ApplicationContextAware接口拿到注解的Service及其实现类。然后使用Netty实现一个NIO的RPC服务器， 同时对服务之间的请求和相应做序列化和反序列化，以及请求进行处理。<br><figure class="highlight plain"><figcaption><span>HippoServerInit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;xxx&quot; /&gt;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>HippoServerInit</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Order</span><br><span class="line">public class HippoServerInit implements ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">  private static final Logger LOG = LoggerFactory.getLogger(HippoServerInit.class);</span><br><span class="line">  @Autowired</span><br><span class="line">  private ServiceGovern serviceGovern;</span><br><span class="line"></span><br><span class="line">  private Set&lt;String&gt; registryNames = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123;</span><br><span class="line">    Map&lt;String, Object&gt; serviceBeanMap = ctx.getBeansWithAnnotation(HippoServiceImpl.class);</span><br><span class="line">    if (MapUtils.isEmpty(serviceBeanMap)) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; implObjectMap = HippoServiceCache.INSTANCE.getImplObjectMap();</span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; interfaceMap = HippoServiceCache.INSTANCE.getInterfaceMap();</span><br><span class="line">    for (Object serviceBean : serviceBeanMap.values()) &#123;</span><br><span class="line">      Class&lt;?&gt;[] interfaces = serviceBean.getClass().getInterfaces();</span><br><span class="line">      for (Class&lt;?&gt; class1 : interfaces) &#123;</span><br><span class="line">        HippoService annotation = class1.getAnnotation(HippoService.class);</span><br><span class="line">        if (annotation == null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果impl实现多个接口,那只需要找到@HippoService的接口即可</span><br><span class="line">        // simpleName 提供apiProcess使用</span><br><span class="line">        String simpleName = class1.getSimpleName();</span><br><span class="line">        // 全限定名提供给rpcProcess使用</span><br><span class="line">        String name = class1.getName();</span><br><span class="line">        if (implObjectMap.containsKey(simpleName)) &#123;</span><br><span class="line">          throw new HippoServiceException(</span><br><span class="line">              &quot;接口[&quot; + simpleName + &quot;]已存在。[&quot; + name + &quot;],hippo不支持不同包名但接口名相同,请重命名当前接口名&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        implObjectMap.put(simpleName, serviceBean);</span><br><span class="line">        implObjectMap.put(name, serviceBean);</span><br><span class="line">        interfaceMap.put(simpleName, class1);</span><br><span class="line">        registryNames.add(annotation.serviceName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    if (registryNames.size() &gt; 1) &#123;</span><br><span class="line">      throw new IllegalAccessError(&quot;多个HippoService的serviceName必须一样[&quot; + registryNames + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(() -&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        Thread.sleep(1);</span><br><span class="line">      &#125; catch (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      int port = serviceGovern.register(registryNames.iterator().next());</span><br><span class="line">      EventLoopGroup bossGroup = new NioEventLoopGroup(1);</span><br><span class="line">      EventLoopGroup workerGroup = new NioEventLoopGroup(1);</span><br><span class="line">      try &#123;</span><br><span class="line">        ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void initChannel(SocketChannel channel) throws Exception &#123;</span><br><span class="line">                channel.pipeline().addLast(new HippoDecoder(HippoRequest.class))</span><br><span class="line">                    .addLast(new HippoEncoder(HippoResponse.class))</span><br><span class="line">                    .addLast(new HippoServerHandler());</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;).option(ChannelOption.SO_BACKLOG, 128).option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line"></span><br><span class="line">        ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">        future.channel().closeFuture().sync();</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        LOG.error(&quot;hippoServer error&quot;, e);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        workerGroup.shutdownGracefully();</span><br><span class="line">        bossGroup.shutdownGracefully();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><p>主要使用protostuff来进行序列化和反序列化，使用Objenesis来实例化对象，无须关心构造方法的变动问题。<br><figure class="highlight plain"><figcaption><span>HippoDecoder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class HippoDecoder extends ByteToMessageDecoder &#123;</span><br><span class="line">  private Class&lt;?&gt; genericClass;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @param genericClass genericClass</span><br><span class="line">   */</span><br><span class="line">  public HippoDecoder(Class&lt;?&gt; genericClass) &#123;</span><br><span class="line">    this.genericClass = genericClass;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;</span><br><span class="line">    if (in.readableBytes() &lt; 4) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    in.markReaderIndex();</span><br><span class="line">    int dataLength = in.readInt();</span><br><span class="line">    if (dataLength &lt; 0) &#123;</span><br><span class="line">      ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">    if (in.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">      in.resetReaderIndex();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    byte[] data = new byte[dataLength];</span><br><span class="line">    in.readBytes(data);</span><br><span class="line">    out.add(SerializationUtils.deserialize(data, genericClass));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>HippoEncoder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HippoEncoder extends MessageToByteEncoder&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private Class&lt;?&gt; genericClass;</span><br><span class="line"></span><br><span class="line">  public HippoEncoder(Class&lt;?&gt; genericClass) &#123;</span><br><span class="line">    this.genericClass = genericClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void encode(ChannelHandlerContext ctx, Object in, ByteBuf out) throws Exception &#123;</span><br><span class="line">    if (genericClass.isInstance(in)) &#123;</span><br><span class="line">      byte[] data = SerializationUtils.serialize(in);</span><br><span class="line">      out.writeInt(data.length);</span><br><span class="line">      out.writeBytes(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而对于HippoRequest和HippoResponse主要负责包装请求和响应的参数<br><figure class="highlight plain"><figcaption><span>HippoRequest</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HippoRequest implements Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = 8703973176164750873L;</span><br><span class="line">  private String serviceName;</span><br><span class="line">  private String requestId;</span><br><span class="line">  private String chainId;</span><br><span class="line">  private int chainOrder;</span><br><span class="line">  private Integer requestType = HippoRequestEnum.RPC.getType();// default</span><br><span class="line">  private String className;</span><br><span class="line">  private String methodName;</span><br><span class="line">  private Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">  private Object[] parameters;</span><br><span class="line">  private transient CallType callType = CallType.SYNC;</span><br><span class="line">  private transient ICallBack iCallBack;</span><br><span class="line">  private transient int timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>HippoResponse</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class HippoResponse implements Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = -2553246569725890161L;</span><br><span class="line">  private String requestId;</span><br><span class="line">  private String serviceName;</span><br><span class="line">  private String chainId;</span><br><span class="line">  private int chainOrder;</span><br><span class="line">  private Object result;</span><br><span class="line">  private Throwable throwable;</span><br><span class="line">  private boolean isError = false;// default if true result is HippoRequest for trace request param</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="RPC远程调用的处理"><a href="#RPC远程调用的处理" class="headerlink" title="RPC远程调用的处理"></a>RPC远程调用的处理</h4><p>对于服务间请求的处理，主要是利用Cglib提供的反射api，进行service调用。这里有两种处理方式apiProcess以及rpcProcess，主要因为核心是网关那一层没有依赖各个服务的api，所以jar所以就走不了rpc调用，因为没有相关接口以及参数。所以这里apiProcess主要用json序列化，而rpcProcess主要用二进制序列化。因此服务之间的rpc调用，如果需要用二进制形式调用，则必须pom引入jar。<br><figure class="highlight plain"><figcaption><span>HippoServerHandler</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">@Sharable</span><br><span class="line">public class HippoServerHandler extends SimpleChannelInboundHandler&lt;HippoRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private static final Logger LOGGER = LoggerFactory.getLogger(HippoServerHandler.class);</span><br><span class="line">  private static final ExecutorService pool =</span><br><span class="line">      Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 3 + 2);</span><br><span class="line"></span><br><span class="line">  private static final ExecutorService heartBeatPool = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">  private void handle(ChannelHandlerContext ctx, HippoRequest request) &#123;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line">    HippoResponse response = new HippoResponse();</span><br><span class="line">    response.setChainId(request.getChainId());</span><br><span class="line">    response.setChainOrder(request.getChainOrder());</span><br><span class="line">    response.setServiceName(request.getServiceName());</span><br><span class="line">    HippoRequestEnum hippoRequestEnum = HippoRequestEnum.getByType(request.getRequestType());</span><br><span class="line">    if (hippoRequestEnum != HippoRequestEnum.PING) &#123;</span><br><span class="line">      LOGGER.info(&quot;hippo in param:&#123;&#125;&quot;, ToStringBuilder.reflectionToString(request));</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      ChainThreadLocal.INSTANCE.setChainId(request.getChainId());</span><br><span class="line">      ChainThreadLocal.INSTANCE.incChainOrder(request.getChainOrder());</span><br><span class="line">      response.setRequestId(request.getRequestId());</span><br><span class="line">      if (hippoRequestEnum == null) &#123;</span><br><span class="line">        response.setError(true);</span><br><span class="line">        response.setThrowable(new HippoRequestTypeNotExistException(</span><br><span class="line">            &quot;HippoRequest requestType not exist.current requestType is:&quot;</span><br><span class="line">                + request.getRequestType()));</span><br><span class="line">      &#125; else if (hippoRequestEnum == HippoRequestEnum.API) &#123;</span><br><span class="line">        response.setResult(apiProcess(request));</span><br><span class="line">      &#125; else if (hippoRequestEnum == HippoRequestEnum.RPC) &#123;</span><br><span class="line">        response.setResult(rpcProcess(request));</span><br><span class="line">      &#125; else if (hippoRequestEnum == HippoRequestEnum.PING) &#123;</span><br><span class="line">        response.setResult(&quot;ping success&quot;);</span><br><span class="line">        response.setRequestId(&quot;-99&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e1) &#123;</span><br><span class="line">      LOGGER.error(&quot;handle error:&quot; + request, e1);</span><br><span class="line">      if (e1 instanceof InvocationTargetException) &#123;</span><br><span class="line">        response.setThrowable(e1.getCause());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        response.setThrowable(e1);</span><br><span class="line">      &#125;</span><br><span class="line">      response.setRequestId(request.getRequestId());</span><br><span class="line">      response.setResult(request);</span><br><span class="line">      response.setError(true);</span><br><span class="line">    &#125;</span><br><span class="line">    ChainThreadLocal.INSTANCE.clearTL();</span><br><span class="line">    if (hippoRequestEnum != HippoRequestEnum.PING) &#123;</span><br><span class="line">      LOGGER.info(&quot;hippo out result:&#123;&#125;,耗时:&#123;&#125;毫秒&quot;, response, System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.writeAndFlush(response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Object rpcProcess(HippoRequest paras) throws InvocationTargetException &#123;</span><br><span class="line">    Object serviceBean = HippoServiceCache.INSTANCE.getImplObjectMap().get(paras.getClassName());</span><br><span class="line">    FastClass serviceFastClass = FastClass.create(serviceBean.getClass());</span><br><span class="line">    FastMethod serviceFastMethod =</span><br><span class="line">        serviceFastClass.getMethod(paras.getMethodName(), paras.getParameterTypes());</span><br><span class="line">    return serviceFastMethod.invoke(serviceBean, paras.getParameters());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Object apiProcess(HippoRequest paras) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    Method[] methods =</span><br><span class="line">        HippoServiceCache.INSTANCE.getInterfaceMap().get(paras.getClassName()).getDeclaredMethods();</span><br><span class="line">    // 接口定义的method</span><br><span class="line">    for (Method method : methods) &#123;</span><br><span class="line">      if (!method.getName().equals(paras.getMethodName())) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      Object[] paramDto = null;</span><br><span class="line"></span><br><span class="line">      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">      Object serviceBean = HippoServiceCache.INSTANCE.getImplObjectMap().get(paras.getClassName());</span><br><span class="line">      FastClass serviceFastClass = FastClass.create(serviceBean.getClass());</span><br><span class="line">      FastMethod serviceFastMethod = serviceFastClass.getMethod(method.getName(), parameterTypes);</span><br><span class="line"></span><br><span class="line">      LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer();</span><br><span class="line">      String[] parameterNames = u.getParameterNames(serviceFastMethod.getJavaMethod());</span><br><span class="line"></span><br><span class="line">      Object[] objects = paras.getParameters();</span><br><span class="line"></span><br><span class="line">      if (parameterTypes.length == 0 || objects == null) &#123;// 无参数</span><br><span class="line">        paramDto = null;</span><br><span class="line">      &#125; else if (parameterTypes.length == 1) &#123;// 一个参数(是否是Dto)</span><br><span class="line">        Class&lt;?&gt; parameterType = parameterTypes[0];</span><br><span class="line">        paramDto = new Object[1];</span><br><span class="line">        // 非自定义dto就是java原生类了</span><br><span class="line">        if (isJavaClass(parameterType)) &#123;</span><br><span class="line">          paramDto[0] = getMap(objects).get(parameterNames[0]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          paramDto[0] = FastJsonConvertUtils.jsonToJavaObject((String) objects[0], parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 多参</span><br><span class="line">      else &#123;</span><br><span class="line">        if (parameterNames.length != 0) &#123;</span><br><span class="line">          paramDto = new Object[parameterNames.length];</span><br><span class="line">          int index = 0;</span><br><span class="line">          Map&lt;String, Object&gt; map = getMap(objects);</span><br><span class="line">          for (String parameter : parameterNames) &#123;</span><br><span class="line">            paramDto[index] = map.get(parameter);</span><br><span class="line">            index++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 拿到返回</span><br><span class="line">      return FastJsonConvertUtils.cleanseToObject(serviceFastMethod.invoke(serviceBean, paramDto));</span><br><span class="line">    &#125;</span><br><span class="line">    throw new NoSuchMethodException(paras.getMethodName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Map&lt;String, Object&gt; getMap(Object[] objects) &#123;</span><br><span class="line">    if (objects.length == 1) &#123;</span><br><span class="line">      return FastJsonConvertUtils.jsonToMap((String) objects[0]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;</span><br><span class="line">    LOGGER.error(&quot;netty server error&quot;, cause.fillInStackTrace());</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void channelRead0(ChannelHandlerContext ctx, HippoRequest request) throws Exception &#123;</span><br><span class="line">    if (request != null &amp;&amp; request.getRequestType() == HippoRequestEnum.PING.getType()) &#123;</span><br><span class="line">      // 单独的线程去执行心跳操作,业务请求不影响心跳</span><br><span class="line">      heartBeatPool.execute(() -&gt; handle(ctx, request));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      pool.execute(() -&gt; handle(ctx, request));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private boolean isJavaClass(Class&lt;?&gt; clz) &#123;</span><br><span class="line">    return clz != null &amp;&amp; clz.getClassLoader() == null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h4><p>默认实现的是eureka实现，其实也可以通过实现该接口使用其他实现。<br><figure class="highlight plain"><figcaption><span>ServiceGovern</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface ServiceGovern &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 服务注册</span><br><span class="line">   * </span><br><span class="line">   * @param serviceName 注册服务名</span><br><span class="line">   * @return 注册时的端口号</span><br><span class="line">   */</span><br><span class="line">  public int register(String serviceName);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 获取服务地址 ip:port </span><br><span class="line">   * 127.0.0.1:7070</span><br><span class="line">   * </span><br><span class="line">   * @param serviceName 注册服务名</span><br><span class="line">   * @return ip:port</span><br><span class="line">   */</span><br><span class="line">  public String getServiceAddress(String serviceName);</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">   * 获取serviceName所有的服务器地址ip:prot</span><br><span class="line">   * @param serviceName 注册服务名</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public List&lt;String&gt;getServiceAddresses(String serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><p>在客户端发送请求的一方，需要时候用HippoClient注解负责实例化服务端的Service<br><figure class="highlight plain"><figcaption><span>OrderServiceImpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@HippoServiceImpl</span><br><span class="line">public class OrderServiceImpl &#123;</span><br><span class="line">  @HippoClient</span><br><span class="line">  UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>HippoClient</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface HippoClient &#123;</span><br><span class="line">  int timeout() default 5000;</span><br><span class="line"></span><br><span class="line">  int retryTimes() default 0;</span><br><span class="line"></span><br><span class="line">  boolean isUseHystrix() default true;</span><br><span class="line"></span><br><span class="line">  boolean isCircuitBreaker() default true;</span><br><span class="line"></span><br><span class="line">  int semaphoreMaxConcurrentRequests() default 10;</span><br><span class="line"></span><br><span class="line">  boolean fallbackEnabled() default false;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; downgradeStrategy() default Void.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="对服务端接口的代理"><a href="#对服务端接口的代理" class="headerlink" title="对服务端接口的代理"></a>对服务端接口的代理</h4><p>基于Spring我们拿到所有HippoCient注解的类后，会对这些类进行动态代理，主要目的当使用了这些service的方法时，对请求进行包装成Request对象</p>
<figure class="highlight plain"><figcaption><span>HippoProxy</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class HippoProxy &#123;</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  &lt;T&gt; T create(Class&lt;?&gt; inferfaceClass, HippoClient hippoClient) &#123;</span><br><span class="line">    return (T) Proxy.newProxyInstance(inferfaceClass.getClassLoader(),</span><br><span class="line">        new Class&lt;?&gt;[] &#123;inferfaceClass&#125;, (proxy, method, args) -&gt; &#123;</span><br><span class="line">          HippoRequest request = new HippoRequest();</span><br><span class="line">          request.setRequestId(UUID.randomUUID().toString());</span><br><span class="line">          request.setChainId(ChainThreadLocal.INSTANCE.getChainId());</span><br><span class="line">          request.setChainOrder(ChainThreadLocal.INSTANCE.getChainOrder());</span><br><span class="line">          request.setRequestType(HippoRequestEnum.RPC.getType());</span><br><span class="line">          request.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">          request.setMethodName(method.getName());</span><br><span class="line">          request.setParameterTypes(method.getParameterTypes());</span><br><span class="line">          request.setParameters(args);</span><br><span class="line">          String serviceName = inferfaceClass.getAnnotation(HippoService.class).serviceName();</span><br><span class="line">          request.setServiceName(serviceName);</span><br><span class="line">          ICallBackBean callBack = CallTypeHelper.SETTING.get();</span><br><span class="line">          if (callBack != null) &#123;</span><br><span class="line">            request.setiCallBack(callBack.getiCallBack());</span><br><span class="line">            request.setCallType(callBack.getCallType());</span><br><span class="line">          &#125;</span><br><span class="line">          ChainThreadLocal.INSTANCE.clearTL();</span><br><span class="line">          HippoCommand hippoCommand =</span><br><span class="line">              new HippoCommand(request, hippoClient.timeout(), hippoClient.retryTimes(),</span><br><span class="line">                  hippoClient.isCircuitBreaker(), hippoClient.semaphoreMaxConcurrentRequests(),</span><br><span class="line">                  hippoClient.downgradeStrategy(), hippoClient.fallbackEnabled());</span><br><span class="line">          HippoResponse hippoResponse;</span><br><span class="line">          // 由于长连接是由定时器线程去持续获得,那如果是junit或者有些请求已经到来也需要获取连接来处理数据</span><br><span class="line">          if (HippoClientBootstrapMap.get(serviceName) == null</span><br><span class="line">              || HippoClientBootstrapMap.get(serviceName).isEmpty()) &#123;</span><br><span class="line">            conntectionOne(serviceName);</span><br><span class="line">          &#125;</span><br><span class="line">          if (hippoClient.isUseHystrix() || hippoClient.isCircuitBreaker()) &#123;</span><br><span class="line">            hippoResponse = (HippoResponse) hippoCommand.execute();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            hippoResponse = hippoCommand.getHippoResponse(request, hippoClient.timeout(),</span><br><span class="line">                hippoClient.retryTimes());</span><br><span class="line">          &#125;</span><br><span class="line">          if (hippoResponse.isError()) &#123;</span><br><span class="line">            throw hippoResponse.getThrowable();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return hippoResponse.getResult();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="与服务端建立TCP连接"><a href="#与服务端建立TCP连接" class="headerlink" title="与服务端建立TCP连接"></a>与服务端建立TCP连接</h4><p>服务端提供的服务都注册在eureka中，我们可以基于服务名拿到注册服务的主机地址和端口，因此我们便可以使用netty进行tcp连接。<br><figure class="highlight plain"><figcaption><span>HippoClientBootstrap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class HippoClientBootstrap implements Comparable&lt;HippoClientBootstrap&gt; &#123;</span><br><span class="line">  private String host;</span><br><span class="line">  private int port;</span><br><span class="line">  private String serviceName;</span><br><span class="line">  private HippoRequestHandler handler;</span><br><span class="line">  private AtomicLong invokeTimes = new AtomicLong(0);</span><br><span class="line">  private NioEventLoopGroup eventLoopGroup;</span><br><span class="line"></span><br><span class="line">  public HippoClientBootstrap(String serviceName, String host, int port) throws Exception &#123;</span><br><span class="line">    this.serviceName = serviceName;</span><br><span class="line">    this.host = host;</span><br><span class="line">    this.port = port;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init() &#123;</span><br><span class="line">    eventLoopGroup = new NioEventLoopGroup(1);</span><br><span class="line">    try &#123;</span><br><span class="line">      Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">      handler = new HippoRequestHandler(this.serviceName, eventLoopGroup, this.host, this.port);</span><br><span class="line">      bootstrap.group(eventLoopGroup);</span><br><span class="line">      bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">      bootstrap.option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line">      bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void initChannel(SocketChannel channel) throws Exception &#123;</span><br><span class="line">          channel.pipeline().addLast(new IdleStateHandler(0, 30, 0, TimeUnit.SECONDS))</span><br><span class="line">              .addLast(new HippoEncoder(HippoRequest.class))</span><br><span class="line">              .addLast(new HippoDecoder(HippoResponse.class)).addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      bootstrap.connect(host, port).sync();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new HippoServiceUnavailableException(</span><br><span class="line">          &quot;[&quot; + this.serviceName + &quot;]服务不可用,初始化失败.host:&quot; + host + &quot;,port:&quot; + port, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而一旦连接建立，当客户端进行远程调用的时候，当调用服务端的方法时，其实本质上是发送一个包含方法及参数的请求包装类，<br>然后通过netty的writeAndFlush操作发送过去，当服务端通过cglib反射调用后拿到返回值时，客户端这边便能在channelRead中进行返回值的接收。<br><figure class="highlight plain"><figcaption><span>HippoRequestHandler</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">public class HippoRequestHandler extends SimpleChannelInboundHandler&lt;HippoResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private static final Logger LOGGER = LoggerFactory.getLogger(HippoRequestHandler.class);</span><br><span class="line"></span><br><span class="line">  private ConcurrentHashMap&lt;String, HippoResultCallBack&gt; callBackMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  private String serviceName;</span><br><span class="line">  private EventLoopGroup eventLoopGroup;</span><br><span class="line">  private Channel channel;</span><br><span class="line">  private String host;</span><br><span class="line">  private int port;</span><br><span class="line"></span><br><span class="line">  public HippoRequestHandler(String serviceName, EventLoopGroup eventLoopGroup, String host,</span><br><span class="line">      int port) &#123;</span><br><span class="line">    this.serviceName = serviceName;</span><br><span class="line">    this.eventLoopGroup = eventLoopGroup;</span><br><span class="line">    this.host = host;</span><br><span class="line">    this.port = port;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    super.channelRegistered(ctx);</span><br><span class="line">    this.channel = ctx.channel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void channelRead0(ChannelHandlerContext arg0, HippoResponse response) throws Exception &#123;</span><br><span class="line">    // ping不需要记录到返回结果MAP里</span><br><span class="line">    if (response != null &amp;&amp; !(&quot;-99&quot;).equals(response.getRequestId())) &#123;</span><br><span class="line">      HippoClientProcessPool.INSTANCE.getPool().execute(() -&gt; &#123;</span><br><span class="line">        HippoResultCallBack hippoResultCallBack = callBackMap.remove(response.getRequestId());</span><br><span class="line">        // oneway方式没有hippoResultCallBack</span><br><span class="line">        if (hippoResultCallBack == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        RemoteCallHandler handler = CallTypeHandler.INSTANCE</span><br><span class="line">            .getHandler(hippoResultCallBack.getHippoRequest().getCallType());</span><br><span class="line">        if (handler != null) &#123;</span><br><span class="line">          handler.back(hippoResultCallBack, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;</span><br><span class="line">    super.userEventTriggered(ctx, evt);</span><br><span class="line">    if (evt instanceof IdleStateEvent) &#123;</span><br><span class="line">      IdleStateEvent e = (IdleStateEvent) evt;</span><br><span class="line">      if (e.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">        HippoRequest hippoRequest = new HippoRequest();</span><br><span class="line">        hippoRequest.setServiceName(serviceName);</span><br><span class="line">        hippoRequest.setRequestId(&quot;-99&quot;);</span><br><span class="line">        hippoRequest.setRequestType(HippoRequestEnum.PING.getType());</span><br><span class="line">        ctx.writeAndFlush(hippoRequest);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">    super.channelInactive(ctx);</span><br><span class="line">    ctx.close();</span><br><span class="line">    if (eventLoopGroup != null) &#123;</span><br><span class="line">      eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    this.callBackMap.values().forEach(c -&gt; &#123;</span><br><span class="line">      HippoResponse response = new HippoResponse();</span><br><span class="line">      response.setError(true);</span><br><span class="line">      response.setThrowable(</span><br><span class="line">          new HippoServiceException(&quot;hippo server error trigger client channelInactive&quot;));</span><br><span class="line">      c.signal(response);</span><br><span class="line">    &#125;);</span><br><span class="line">    callBackMap.clear();</span><br><span class="line"></span><br><span class="line">    HippoClientBootstrapMap.remove(serviceName, host, port);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void sendAsync(HippoResultCallBack hippoResultCallBack) &#123;</span><br><span class="line">    callBackMap.put(hippoResultCallBack.getHippoRequest().getRequestId(), hippoResultCallBack);</span><br><span class="line">    this.channel.writeAndFlush(hippoResultCallBack.getHippoRequest());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HippoResponse sendOneWay(HippoRequest hippoRequest) &#123;</span><br><span class="line">    this.channel.writeAndFlush(hippoRequest);</span><br><span class="line">    return buildEmptyHippoResponse(hippoRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HippoResponse sendWithCallBack(HippoResultCallBack hippoResultCallBack) &#123;</span><br><span class="line">    sendAsync(hippoResultCallBack);</span><br><span class="line">    return buildEmptyHippoResponse(hippoResultCallBack.getHippoRequest());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private HippoResponse buildEmptyHippoResponse(HippoRequest hippoRequest) &#123;</span><br><span class="line">    HippoResponse hippoResponse = new HippoResponse();</span><br><span class="line">    hippoResponse.setRequestId(hippoRequest.getRequestId());</span><br><span class="line">    hippoResponse.setChainId(hippoRequest.getChainId());</span><br><span class="line">    hippoResponse.setChainOrder(hippoRequest.getChainOrder());</span><br><span class="line">    return hippoResponse;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">    LOGGER.error(&quot;netty client error&quot;, cause.fillInStackTrace());</span><br><span class="line">    HippoClientBootstrapMap.remove(serviceName, host, port);</span><br><span class="line">    ctx.close();</span><br><span class="line">    if (eventLoopGroup != null) &#123;</span><br><span class="line">      eventLoopGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="服务间调用的处理"><a href="#服务间调用的处理" class="headerlink" title="服务间调用的处理"></a>服务间调用的处理</h4><p>首先对服务可能存在会挂掉的情况，所以这里使用了Hystrix对熔断和降级处理。<br><figure class="highlight plain"><figcaption><span>HippoCommand</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public class HippoCommand extends HystrixCommand&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">  private HippoRequest hippoRequest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private HippoResponse hippoResponse;</span><br><span class="line"></span><br><span class="line">  private int timeout;</span><br><span class="line"></span><br><span class="line">  private int retryTimes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private HippoFailPolicy&lt;?&gt; hippoFailPolicy;</span><br><span class="line"></span><br><span class="line">  public HippoCommand(HippoRequest hippoRequest, int timeOut, int retryTimes,</span><br><span class="line">      boolean isCircuitBreaker, int semaphoreMaxConcurrentRequests, Class&lt;?&gt; downgradeStrategy,</span><br><span class="line">      boolean fallbackEnabled) throws InstantiationException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">    // 默认隔离策略是线程 也可以是信号量,现在采用的是信号量的模式</span><br><span class="line">    // 信号量隔离是个限流的策略</span><br><span class="line">    // 因为是自己实现的超时机制，所以关闭hystrix的超时机制</span><br><span class="line">    super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(hippoRequest.getServiceName()))</span><br><span class="line">        .andCommandKey(HystrixCommandKey.Factory.asKey(hippoRequest.getClassName()))</span><br><span class="line">        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">            .withExecutionIsolationStrategy(</span><br><span class="line">                HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">            .withExecutionIsolationSemaphoreMaxConcurrentRequests(semaphoreMaxConcurrentRequests)</span><br><span class="line">            .withFallbackEnabled(fallbackEnabled).withCircuitBreakerEnabled(isCircuitBreaker)</span><br><span class="line">            .withExecutionTimeoutEnabled(false)));</span><br><span class="line"></span><br><span class="line">    this.hippoRequest = hippoRequest;</span><br><span class="line">    this.timeout = timeOut;</span><br><span class="line">    this.retryTimes = retryTimes;</span><br><span class="line"></span><br><span class="line">    if (fallbackEnabled) &#123;</span><br><span class="line">      init(downgradeStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void init(Class&lt;?&gt; downgradeStrategy)</span><br><span class="line">      throws InstantiationException, IllegalAccessException &#123;</span><br><span class="line">    if (HippoFailPolicy.class.isAssignableFrom(downgradeStrategy)) &#123;</span><br><span class="line">      // 先从spring容器里面拿，如果没有，则new</span><br><span class="line">      try &#123;</span><br><span class="line">        Object bean = HippoClientInit.getApplicationContext().getBean(downgradeStrategy);</span><br><span class="line">        hippoFailPolicy = (HippoFailPolicy&lt;?&gt;) bean;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        hippoFailPolicy = (HippoFailPolicy&lt;?&gt;) downgradeStrategy.newInstance();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      hippoFailPolicy = new HippoFailPolicyDefaultImpl();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected Object run() throws Exception &#123;</span><br><span class="line">    HippoResponse result = getHippoResponse(hippoRequest, timeout, retryTimes);</span><br><span class="line">    // 超时异常记录到熔断器里</span><br><span class="line">    // 看看后续有没必要加上排他异常(比如如果是xxx异常也可以不触发fallback类似HystrixBadRequestException)</span><br><span class="line">    if (result.isError() &amp;&amp; result.getThrowable() instanceof HippoReadTimeoutException) &#123;</span><br><span class="line">      hippoResponse = result;</span><br><span class="line">      throw (HippoReadTimeoutException) result.getThrowable();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected Object getFallback() &#123;</span><br><span class="line">    return hippoFailPolicy.failCallBack(hippoResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HippoResponse getHippoResponse(HippoRequest request, int timeout, int retryTimes)</span><br><span class="line">      throws Exception &#123;</span><br><span class="line">    HippoResponse result = getResult(request, timeout);</span><br><span class="line">    if (result.isError() &amp;&amp; result.getThrowable() instanceof HippoReadTimeoutException</span><br><span class="line">        &amp;&amp; retryTimes &gt; 0) &#123;</span><br><span class="line">      return getHippoResponse(request, timeout, retryTimes - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private HippoResponse getResult(HippoRequest request, int timeout) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    HippoClientBootstrap hippoClientBootstrap =</span><br><span class="line">        HippoClientBootstrapMap.getBootstrap(request.getServiceName());</span><br><span class="line">    if (hippoClientBootstrap == null) &#123;</span><br><span class="line">      throw new HippoServiceUnavailableException(&quot;[&quot; + request.getServiceName() + &quot;]没有可用的服务&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteCallHandler handler = CallTypeHandler.INSTANCE.getHandler(request.getCallType());</span><br><span class="line">    if (handler == null) &#123;</span><br><span class="line">      throw new HippoRequestTypeNotExistException(request.getCallType() + &quot;不符合的现有的callType&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return handler.call(hippoClientBootstrap, hippoRequest, timeout);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而服务间调用方式大致可以分成三种类型，及同步，异步，单向调用不需返回值。不同的调用方式反馈在netty处理response的操作不同。这里的同步调用其实本质上是异步，只不过阻塞了方法。当response返回的时候，停止阻塞<br><figure class="highlight plain"><figcaption><span>CallType</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public enum CallType &#123;</span><br><span class="line">  SYNC(&quot;同步调用&quot;), ONEWAY(&quot;单向发送不需要拿返回结果&quot;), ASYNC(&quot;异步调用,可以从callback拿返回结果&quot;);</span><br><span class="line"></span><br><span class="line">  private String desc;</span><br><span class="line"></span><br><span class="line">  CallType(String desc) &#123;</span><br><span class="line">    this.desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public String getDesc() &#123;</span><br><span class="line">    return desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>RemoteCallHandler</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface RemoteCallHandler &#123;</span><br><span class="line"></span><br><span class="line">  HippoResponse call(HippoClientBootstrap HippoClientBootstrap, HippoRequest hippoRequest,</span><br><span class="line">      int timeOut) throws Exception;</span><br><span class="line"></span><br><span class="line">  void back(HippoResultCallBack hippoResultCallBack, HippoResponse hippoResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><figcaption><span>HippoResultCallBack</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class HippoResultCallBack &#123;</span><br><span class="line">  private Lock lock = new ReentrantLock();</span><br><span class="line">  private Condition finish = lock.newCondition();</span><br><span class="line">  private int timeout;</span><br><span class="line">  private HippoResponse hippoResponse;</span><br><span class="line">  private HippoRequest hippoRequest;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  public HippoRequest getHippoRequest() &#123;</span><br><span class="line">    return hippoRequest;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  protected HippoResultCallBack(HippoRequest hippoRequest, int timeout) &#123;</span><br><span class="line">    this.hippoRequest = hippoRequest;</span><br><span class="line">    this.timeout = timeout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void signal(HippoResponse hippoResponse) &#123;</span><br><span class="line">    this.hippoResponse = hippoResponse;</span><br><span class="line">    try &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      finish.signal();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HippoResponse getResult() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      int waitTime = timeout;</span><br><span class="line">      lock.lock();</span><br><span class="line">      // 最大1分钟超时</span><br><span class="line">      if (waitTime &lt;= 0) &#123;</span><br><span class="line">        waitTime = 60000;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!finish.await(waitTime, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        hippoResponse = new HippoResponse();</span><br><span class="line">        BeanUtils.copyProperties(hippoRequest, hippoResponse);</span><br><span class="line">        hippoResponse.setError(true);</span><br><span class="line">        hippoResponse.setRequestId(hippoRequest.getRequestId());</span><br><span class="line">        hippoResponse.setThrowable(</span><br><span class="line">            new HippoReadTimeoutException(&quot;[&quot; + hippoRequest + &quot;]超时,超时时间[&quot; + waitTime + &quot;]毫秒&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">      hippoResponse = new HippoResponse();</span><br><span class="line">      BeanUtils.copyProperties(hippoRequest, hippoResponse);</span><br><span class="line">      hippoResponse.setError(true);</span><br><span class="line">      hippoResponse.setThrowable(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return hippoResponse;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/22/路由设计/" rel="next" title="移动端路由设计">
                <i class="fa fa-chevron-left"></i> 移动端路由设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/13860006?s=460&v=4"
                alt="Kevin Hao" />
            
              <p class="site-author-name" itemprop="name">Kevin Hao</p>
              <p class="site-description motion-element" itemprop="description">This is description</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端注册"><span class="nav-number">2.</span> <span class="nav-text">服务端注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化与反序列化"><span class="nav-number">3.</span> <span class="nav-text">序列化与反序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC远程调用的处理"><span class="nav-number">4.</span> <span class="nav-text">RPC远程调用的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务治理"><span class="nav-number">5.</span> <span class="nav-text">服务治理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端使用"><span class="nav-number">6.</span> <span class="nav-text">客户端使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对服务端接口的代理"><span class="nav-number">7.</span> <span class="nav-text">对服务端接口的代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与服务端建立TCP连接"><span class="nav-number">8.</span> <span class="nav-text">与服务端建立TCP连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务间调用的处理"><span class="nav-number">9.</span> <span class="nav-text">服务间调用的处理</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Hao</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
